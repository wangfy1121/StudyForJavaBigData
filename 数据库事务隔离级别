1.事务transaction
	数据库事务(Database Transaction)
	是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。
	
	简单的说：事务就是将一堆的SQL语句(通常是增删改操作)绑定在一起执行
	要么都执行成功，要么都执行失败，即都执行成功才算成功，否则就会恢复到这堆SQL执行之前的状态。
	
	（1）事务的四个特性：ACID
			原子性（Atomicity，或称不可分割性）：多条SQL是一个密不可分的整体
			一致性（Consistency）：分布式系统，数据的一致性
			隔离性（Isolation，又称独立性）：数据库支持高并发，使用了锁的机制保证了数据的安全
			持久性（Durability）：是指对数据的增删改是永久性的
	
			原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
					事务在执行过程中如果发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
			一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，
					这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
			隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力
					隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
			持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
			
	（2）隔离级别
	
			1）读未提交（Read uncommitted）：
			
					第一事务在读操作时，第二事务可读可写
					第一事务在写操作时，第二事务可读可写
				优缺点：解决了更新丢失，但还是可能会出现脏读
			
			2）读已提交（Read committed）：（Oracle默认级别）
			
					第一事务在读操作时，第二事务可读可写
					第一事务在写操作时，第二事务不可读不可写
				
				mysql好像不支持这种隔离级别，无法验证
				优缺点：解决了更新丢失和脏读问题
			
			
			3）可重复读（Repeatable read）：（MySQL默认级别）
			
					第一事务在读操作时，第二事务可读不可写
					第一事务在写操作时，第二事务不可读不可写
				优缺点：解决了更新丢失、脏读、不可重复读、但是还会出现幻读
			
			4）可串行化/可序列化（Serializable）：
				
				提供严格的事务隔离，它要求事务序列化执行，
				事务只能一个接着一个地执行，但不能并发执行
				
				mysql好像不支持这种隔离级别，无法验证
				优缺点：解决了更新丢失、脏读、不可重复读、幻读(虚读)

	
	（3）脏读、幻读、不可重复读
	
			
			
			脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，
				    这时，另外一个事务也访问这个数据，然后使用了这个数据。
				
					例如：
					 张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。
					 与此同时，
					 事务B正在读取张三的工资，读取到张三的工资为8000。
					 随后，
					 事务A发生异常，而回滚了事务。张三的工资又回滚为5000。
					 最后，
					 事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。
			
			不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
					例如：
					 在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。
					 与此同时，
					 事务B把张三的工资改为8000，并提交了事务。
					 随后，
					 在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。
	
			幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
					例如：
					 目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。
					 此时，
					 事务B插入一条工资也为5000的记录。
					 这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。
				
		【注意】
				脏读的重点是读：
				读到另一未提交的事务中修改后的数据，而另一事务也许不会提交
				不可重复读的重点是修改： 
				 同样的条件，你读取过的数据，再次读取出来发现值不一样了
				 幻读的重点在于新增或者删除： 
				 同样的条件，第 1 次和第 2 次读出来的记录数不一样
		
2.字段约束
	（1）默认约束：default 使用默认约束设置默认值
				CREATE TABLE x1(
				id INT PRIMARY KEY AUTO_INCREMENT,
				sex CHAR(3) DEFAULT '男' #设置了默认值
				);
				
				
	
	（2）检查约束：check检查字段是否合法
				CREATE TABLE x2(
				id INT PRIMARY KEY AUTO_INCREMENT,
				age INT,
				CHECK(age<100)#检查约束，满足条件才能保存
				);
				
	
	（3）外键约束
			语法：foreign key(当前表的主键名) references 对方表名(对方主键)
			#主表
				CREATE TABLE tb_user(
				id INT PRIMARY KEY AUTO_INCREMENT,
				NAME VARCHAR(10),
				age INT
				);
			#子表
				CREATE TABLE tb_user_address(
				user_id INT PRIMARY KEY,
				address VARCHAR(100),
				FOREIGN KEY(user_id) REFERENCES tb_user(id)
				);
			
